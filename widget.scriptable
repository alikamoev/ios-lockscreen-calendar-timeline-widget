{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "blue",
    "glyph" : "clock"
  },
  "name" : "Day Timeline",
  "script" : "async function createWidget() {\n    \/\/ Создаем виджет\n    let widget = new ListWidget();\n\n    \/\/ Устанавливаем размеры для рисования\n    let width = 172; \/\/ Ширина виджета\n    let height = 76; \/\/ Высота виджета\n    let lineThickness = 0.69; \/\/ Толщина линий времени\n    let currentTimeLineThickness = 1; \/\/ Толщина линии текущего времени\n    let lineHeight = 50; \/\/ Высота линий\n    let verticalPadding = 7; \/\/ Вертикальные отступы от верхней границы до линий\n    let bottomPadding = 4; \/\/ Отступ от нижней границы линий до текста\n    let circleRadius = 3.5; \/\/ Радиус круга\n\n    let drawContext = new DrawContext();\n    drawContext.size = new Size(width, height);\n    drawContext.opaque = false;\n    drawContext.respectScreenScale = true;\n\n    let currentDate = new Date();\n    let currentHour24 = currentDate.getHours();\n    let currentMinute = currentDate.getMinutes();\n    let currentTotalMinutes = currentHour24 * 60 + currentMinute;\n\n    let padding = width \/ 10.5;\n    let usableWidth = width - 2 * padding;\n    let spacing = usableWidth \/ 3;\n\n    \/\/ Загрузка событий за три дня: вчера, сегодня и завтра\n    let events = await Promise.all([\n        CalendarEvent.between(new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate() - 1),\n                              new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate())),\n        CalendarEvent.between(new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate()),\n                              new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate() + 1)),\n        CalendarEvent.between(new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate() + 1),\n                              new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate() + 2))\n    ]).then(results => results.flat().filter(event => !event.isAllDay));\n\n    \/\/ Удаление дубликатов\n    let uniqueEvents = events.reduce((acc, current) => {\n        let duplicate = acc.find(event => event.title === current.title && event.startDate.getTime() === current.startDate.getTime() && event.endDate.getTime() === current.endDate.getTime());\n        if (!duplicate) {\n            acc.push(current);\n        }\n        return acc;\n    }, []);\n\n    let levels = [];\n    let lastUsedIndex = -1;\n\n    function findLevel(start, end) {\n        let maxLevels = 3;\n        for (let i = 0; i < maxLevels; i++) {\n            let levelIndex = (lastUsedIndex + 1 + i) % maxLevels;\n            if (!levels[levelIndex] || !levels[levelIndex].some(e => start < e.end && end > e.start)) {\n                lastUsedIndex = levelIndex;\n                return levelIndex;\n            }\n        }\n        return 0;\n    }\n\n    uniqueEvents.forEach(event => {\n        let startDateTime = new Date(event.startDate);\n        let endDateTime = new Date(event.endDate);\n        let startHour = startDateTime.getHours() + startDateTime.getMinutes() \/ 60 + (startDateTime.getDate() - currentDate.getDate()) * 24;\n        let endHour = endDateTime.getHours() + endDateTime.getMinutes() \/ 60 + (endDateTime.getDate() - currentDate.getDate()) * 24;\n        let level = findLevel(startHour, endHour);\n        if (!levels[level]) levels[level] = [];\n        levels[level].push({ start: startHour, end: endHour, event });\n    });\n\n    for (let i = 0; i < 4; i++) {\n        let hour = (currentHour24 + i) % 24;\n        let displayHour = hour % 12 || 12;\n        let suffix = hour >= 12 && hour < 24 ? \"pm\" : \"am\";\n        let x = padding + i * spacing + lineThickness \/ 2;\n\n        drawContext.setFillColor(new Color(\"#FFFFFF\", 0.65));\n        drawContext.fillRect(new Rect(x - lineThickness \/ 2, verticalPadding, lineThickness, lineHeight));\n\n        drawContext.setTextColor(new Color(\"#FFFFFF\"));\n        drawContext.setFont(Font.systemFont(13));\n        let hourText = `${displayHour}${suffix}`;\n        let textWidth = hourText.length * 8;\n        let textX = x - (textWidth \/ 2);\n        let textY = verticalPadding + lineHeight + bottomPadding;\n        drawContext.drawText(hourText, new Point(textX, textY));\n    }\n\n    let currentTimeLineX = padding + ((currentHour24 + currentMinute \/ 60) - currentHour24) * spacing;\n    drawContext.setFillColor(new Color(\"#FFFFFF\", 1));\n    drawContext.fillRect(new Rect(currentTimeLineX, verticalPadding, currentTimeLineThickness, lineHeight));\n\n    let circleCenterX = currentTimeLineX + currentTimeLineThickness \/ 2 - circleRadius;\n    let circleCenterY = verticalPadding - circleRadius - 3 + 2;\n    drawContext.fillEllipse(new Rect(circleCenterX, circleCenterY, circleRadius * 2, circleRadius * 2));\n\n    levels.forEach((level, idx) => {\n        level.forEach(({ start, end, event }) => {\n            let startX = padding + ((start - currentHour24) * spacing);\n            let endX = padding + ((end - currentHour24) * spacing);\n            let eventWidth = endX - startX;\n            let eventHeight = lineHeight * 0.2;\n            let eventY = verticalPadding + lineHeight * (0.18 + idx * 0.22);\n\n            let cornerRadius = eventHeight \/ 2;\n            let opacity = (event.startDate <= currentDate && event.endDate >= currentDate) || event.endDate <= currentDate ? 0.23 : 0.65;\n            let eventRect = new Path();\n            eventRect.addRoundedRect(new Rect(startX, eventY, eventWidth, eventHeight), cornerRadius, cornerRadius);\n            drawContext.setFillColor(new Color(\"#FFFFFF\", opacity));\n            drawContext.addPath(eventRect);\n            drawContext.fillPath();\n        });\n    });\n\n    let image = drawContext.getImage();\n\n    let imageElement = widget.addImage(image);\n    imageElement.centerAlignImage();\n\n    widget.presentMedium();\n\n    let nextRefresh = new Date();\n    nextRefresh.setMinutes(currentDate.getMinutes() + 3);\n    nextRefresh.setSeconds(0);\n    widget.refreshAfterDate = nextRefresh;\n\n    Script.setWidget(widget);\n    Script.complete();\n}\n\ncreateWidget();",
  "share_sheet_inputs" : [

  ]
}